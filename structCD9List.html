<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>My Project: CD9List Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structCD9List-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CD9List Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae11a7aba052a50912e5087c70829b7b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae11a7aba052a50912e5087c70829b7b3"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>length</b></td></tr>
<tr class="separator:ae11a7aba052a50912e5087c70829b7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a9a44e4acd4f04e1d559fb023f97be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2a9a44e4acd4f04e1d559fb023f97be"></a>
<a class="el" href="structCD9Node.html">CD9Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>nodes</b></td></tr>
<tr class="separator:aa2a9a44e4acd4f04e1d559fb023f97be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc6ebdef414cb3f18900b9f15484196"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCD9List.html#a2fc6ebdef414cb3f18900b9f15484196">append</a> )(void *self, const void *data)</td></tr>
<tr class="memdesc:a2fc6ebdef414cb3f18900b9f15484196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function whenever you want to append something to the end of the list. This is just a wrapper for <code>_insertCopy</code>.  <a href="#a2fc6ebdef414cb3f18900b9f15484196">More...</a><br/></td></tr>
<tr class="separator:a2fc6ebdef414cb3f18900b9f15484196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7cac339279f3a9fd16972f5e5f572b7"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCD9List.html#aa7cac339279f3a9fd16972f5e5f572b7">appendCopy</a> )(void *self, const void *data, size_t size)</td></tr>
<tr class="memdesc:aa7cac339279f3a9fd16972f5e5f572b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function when you want to append a copy of the data not just keeping a reference to it in the list. You will want to do this when the lifetime of the list will be longer than the lifetime of the data you want to append. For example, you want to append some values created in a function to a list. After the function returns, these values won't be available anymore, so the list will have a broken reference. Using this function you can avoid this kind of scenarios. This is a wrapped over <code>cd9list_insertCopy</code>.  <a href="#aa7cac339279f3a9fd16972f5e5f572b7">More...</a><br/></td></tr>
<tr class="separator:aa7cac339279f3a9fd16972f5e5f572b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83bf6e968ecd901f6268b3e2eee7c990"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCD9List.html#a83bf6e968ecd901f6268b3e2eee7c990">prepend</a> )(void *self, const void *data)</td></tr>
<tr class="memdesc:a83bf6e968ecd901f6268b3e2eee7c990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function whenever you want to add a new node at the beggining of the list.  <a href="#a83bf6e968ecd901f6268b3e2eee7c990">More...</a><br/></td></tr>
<tr class="separator:a83bf6e968ecd901f6268b3e2eee7c990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9889d78ce07976ad9969470d7b6446e"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCD9List.html#af9889d78ce07976ad9969470d7b6446e">prependCopy</a> )(void *self, const void *data, size_t size)</td></tr>
<tr class="memdesc:af9889d78ce07976ad9969470d7b6446e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is similar to <a class="el" href="structCD9List.html#aa7cac339279f3a9fd16972f5e5f572b7">appendCopy</a>, the only difference is that it appends the copy at the beginning of the list.  <a href="#af9889d78ce07976ad9969470d7b6446e">More...</a><br/></td></tr>
<tr class="separator:af9889d78ce07976ad9969470d7b6446e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e33d6d363a8eb355d9e0cc1150a53b"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCD9List.html#ae7e33d6d363a8eb355d9e0cc1150a53b">get</a> )(void *self, size_t index)</td></tr>
<tr class="memdesc:ae7e33d6d363a8eb355d9e0cc1150a53b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function to get the data of the node stored at that index.  <a href="#ae7e33d6d363a8eb355d9e0cc1150a53b">More...</a><br/></td></tr>
<tr class="separator:ae7e33d6d363a8eb355d9e0cc1150a53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff55079f64675c21d70c56034f4ed96"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCD9List.html#a7ff55079f64675c21d70c56034f4ed96">pop</a> )(void *self)</td></tr>
<tr class="memdesc:a7ff55079f64675c21d70c56034f4ed96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to delete the last element in the list and to delete it.  <a href="#a7ff55079f64675c21d70c56034f4ed96">More...</a><br/></td></tr>
<tr class="separator:a7ff55079f64675c21d70c56034f4ed96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d6db446dae3ee54db0d32e5eae9d47"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCD9List.html#ac0d6db446dae3ee54db0d32e5eae9d47">popleft</a> )(void *self)</td></tr>
<tr class="memdesc:ac0d6db446dae3ee54db0d32e5eae9d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use thid function to get the first element from the list and to delete it.  <a href="#ac0d6db446dae3ee54db0d32e5eae9d47">More...</a><br/></td></tr>
<tr class="separator:ac0d6db446dae3ee54db0d32e5eae9d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac391375276a5d2abccaac0bdf6cea24a"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCD9List.html#ac391375276a5d2abccaac0bdf6cea24a">insert</a> )(void *self, size_t index, const void *data)</td></tr>
<tr class="memdesc:ac391375276a5d2abccaac0bdf6cea24a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to insert an item at the given list. If you pass an invalid index the function won't insert the value at all. This is a wrapper for <code>cd9list_insertCopy</code>, but it doesn't make a copy of the data you want to store, it just stores the address you give to him.  <a href="#ac391375276a5d2abccaac0bdf6cea24a">More...</a><br/></td></tr>
<tr class="separator:ac391375276a5d2abccaac0bdf6cea24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89b586c2023685f16194effe3e79bd5"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCD9List.html#aa89b586c2023685f16194effe3e79bd5">find</a> )(void *self, const void *data, CD9FindCallback cmp)</td></tr>
<tr class="memdesc:aa89b586c2023685f16194effe3e79bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to get the index of the first occurence of <code>data</code> in the list.  <a href="#aa89b586c2023685f16194effe3e79bd5">More...</a><br/></td></tr>
<tr class="separator:aa89b586c2023685f16194effe3e79bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d0f916a39b661836528fa9238abb99"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCD9List.html#a44d0f916a39b661836528fa9238abb99">findByAddress</a> )(void *self, const void *data)</td></tr>
<tr class="memdesc:a44d0f916a39b661836528fa9238abb99"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is a wrapper over <code>cd9list_find</code>. It is intended to ease the finding of elements in a list which stores addresses not copies of the data.  <a href="#a44d0f916a39b661836528fa9238abb99">More...</a><br/></td></tr>
<tr class="separator:a44d0f916a39b661836528fa9238abb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8833db5072ccff1a70608394b0b05d00"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCD9List.html#a8833db5072ccff1a70608394b0b05d00">findByValue</a> )(void *self, const void *data)</td></tr>
<tr class="memdesc:a8833db5072ccff1a70608394b0b05d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for <code>cd9list_find</code>. It is intended to make your life easier if you need to find values in a list that stores copies, and by "copies" I mean pointers to copies.  <a href="#a8833db5072ccff1a70608394b0b05d00">More...</a><br/></td></tr>
<tr class="separator:a8833db5072ccff1a70608394b0b05d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4511b437cc1e26de0d1143377101310b"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCD9List.html#a4511b437cc1e26de0d1143377101310b">remove</a> )(void *self, size_t index)</td></tr>
<tr class="memdesc:a4511b437cc1e26de0d1143377101310b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to remove the element at the index specified as argument.  <a href="#a4511b437cc1e26de0d1143377101310b">More...</a><br/></td></tr>
<tr class="separator:a4511b437cc1e26de0d1143377101310b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a233b0312849ac52c75b3118d191bc"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCD9List.html#a55a233b0312849ac52c75b3118d191bc">_insertCopy</a> )(void *self, size_t index, const void *value, size_t size)</td></tr>
<tr class="memdesc:a55a233b0312849ac52c75b3118d191bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normally, when you use functions like <code>append</code> or <code>prepend</code> you just add a pointer to the data. If that data is destroyed the list element will be useless, since the data it points to doesn't exist anymore. Using this function to add a new element the list will make a copy of the data itself. Thus, even if you delete the original data, it won't matter because the list element points to data allocated by itself.  <a href="#a55a233b0312849ac52c75b3118d191bc">More...</a><br/></td></tr>
<tr class="separator:a55a233b0312849ac52c75b3118d191bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12c45ac52b3b1eba1d8bafb48401427"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCD9List.html#ab12c45ac52b3b1eba1d8bafb48401427">reverse</a> )(void *self)</td></tr>
<tr class="memdesc:ab12c45ac52b3b1eba1d8bafb48401427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to reverse the current list.  <a href="#ab12c45ac52b3b1eba1d8bafb48401427">More...</a><br/></td></tr>
<tr class="separator:ab12c45ac52b3b1eba1d8bafb48401427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657d8c925f83b92eeb706b3de78c6db7"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structCD9List.html">CD9List</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCD9List.html#a657d8c925f83b92eeb706b3de78c6db7">copy</a> )(void *self)</td></tr>
<tr class="memdesc:a657d8c925f83b92eeb706b3de78c6db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to get a copy of the current function. Be aware that it will allocate a new block of memory and will copy the contents of the current list, so you will really get a copy of the current list.  <a href="#a657d8c925f83b92eeb706b3de78c6db7">More...</a><br/></td></tr>
<tr class="separator:a657d8c925f83b92eeb706b3de78c6db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c60ff759f31e18fd617183b85b5d69"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structCD9List.html">CD9List</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCD9List.html#a35c60ff759f31e18fd617183b85b5d69">slice</a> )(void *self, int start, int stop, size_t step)</td></tr>
<tr class="memdesc:a35c60ff759f31e18fd617183b85b5d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to receive a slice of the current list. The "slice" is a pointer to a a newly allocated block of memory which contains a portion of the current list.  <a href="#a35c60ff759f31e18fd617183b85b5d69">More...</a><br/></td></tr>
<tr class="separator:a35c60ff759f31e18fd617183b85b5d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaacc616c1a41f08feaef507b40dae30a"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCD9List.html#aaacc616c1a41f08feaef507b40dae30a">sort</a> )(void *self, int(*cmp)(const void *a, const void *b))</td></tr>
<tr class="memdesc:aaacc616c1a41f08feaef507b40dae30a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to sort a list.  <a href="#aaacc616c1a41f08feaef507b40dae30a">More...</a><br/></td></tr>
<tr class="separator:aaacc616c1a41f08feaef507b40dae30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98612ea0006b4f6541565118e3b36d56"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structCD9List.html">CD9List</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCD9List.html#a98612ea0006b4f6541565118e3b36d56">filter</a> )(void *self, const void *data, CD9FindCallback cmp)</td></tr>
<tr class="memdesc:a98612ea0006b4f6541565118e3b36d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to filter a list by particular elements.  <a href="#a98612ea0006b4f6541565118e3b36d56">More...</a><br/></td></tr>
<tr class="separator:a98612ea0006b4f6541565118e3b36d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5d7f9a4582624c32b0d73269adcd8a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structCD9List.html">CD9List</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCD9List.html#a1c5d7f9a4582624c32b0d73269adcd8a">filterByValue</a> )(void *self, const void *data)</td></tr>
<tr class="memdesc:a1c5d7f9a4582624c32b0d73269adcd8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">You will use this function in order to filter a list by a given value, but this time you don't have to provide a comparator, since the built-in comparator will be used.  <a href="#a1c5d7f9a4582624c32b0d73269adcd8a">More...</a><br/></td></tr>
<tr class="separator:a1c5d7f9a4582624c32b0d73269adcd8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7555b1bbb189fba0b25908b37a749beb"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structCD9List.html">CD9List</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCD9List.html#a7555b1bbb189fba0b25908b37a749beb">filterBySet</a> )(void *self, struct <a class="el" href="structCD9List.html">CD9List</a> *set)</td></tr>
<tr class="memdesc:a7555b1bbb189fba0b25908b37a749beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">You will, usually, use this function when you want to eliminate more than one value from a list.  <a href="#a7555b1bbb189fba0b25908b37a749beb">More...</a><br/></td></tr>
<tr class="separator:a7555b1bbb189fba0b25908b37a749beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a55a233b0312849ac52c75b3118d191bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* CD9List::_insertCopy)(void *self, size_t index, const void *value, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normally, when you use functions like <code>append</code> or <code>prepend</code> you just add a pointer to the data. If that data is destroyed the list element will be useless, since the data it points to doesn't exist anymore. Using this function to add a new element the list will make a copy of the data itself. Thus, even if you delete the original data, it won't matter because the list element points to data allocated by itself. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The current list. </td></tr>
    <tr><td class="paramname">index</td><td>The position where you want to insert the new item. </td></tr>
    <tr><td class="paramname">value</td><td>The value you want to insert. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data you want to insert, thus the function will know how much memory should allocate when creating the copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void It doesn't return anything. </dd></dl>

</div>
</div>
<a class="anchor" id="a2fc6ebdef414cb3f18900b9f15484196"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* CD9List::append)(void *self, const void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this function whenever you want to append something to the end of the list. This is just a wrapper for <code>_insertCopy</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A pointer to the list. </td></tr>
    <tr><td class="paramname">data</td><td>The data you want to append. It must be typecsted to void *.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void It doesn't return anything. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7cac339279f3a9fd16972f5e5f572b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* CD9List::appendCopy)(void *self, const void *data, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use this function when you want to append a copy of the data not just keeping a reference to it in the list. You will want to do this when the lifetime of the list will be longer than the lifetime of the data you want to append. For example, you want to append some values created in a function to a list. After the function returns, these values won't be available anymore, so the list will have a broken reference. Using this function you can avoid this kind of scenarios. This is a wrapped over <code>cd9list_insertCopy</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The current list. </td></tr>
    <tr><td class="paramname">data</td><td>The data you want to append. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data you want to append. This is necessary because we need to know how large should be the block of memory allocated for the copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void It doesn't return anything. </dd></dl>

</div>
</div>
<a class="anchor" id="a657d8c925f83b92eeb706b3de78c6db7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structCD9List.html">CD9List</a>*(* CD9List::copy)(void *self)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use this function to get a copy of the current function. Be aware that it will allocate a new block of memory and will copy the contents of the current list, so you will really get a copy of the current list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The current list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structCD9List.html">CD9List</a> * A pointer to the copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a98612ea0006b4f6541565118e3b36d56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structCD9List.html">CD9List</a>*(* CD9List::filter)(void *self, const void *data, CD9FindCallback cmp)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use this function to filter a list by particular elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The current list. </td></tr>
    <tr><td class="paramname">data</td><td>This data will e passed to the <code>cmp</code> at every call. </td></tr>
    <tr><td class="paramname">cmp</td><td>The comparator function used to determine if an element should be filtered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structCD9List.html">CD9List</a> * It returns the filtered list. </dd></dl>

</div>
</div>
<a class="anchor" id="a7555b1bbb189fba0b25908b37a749beb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structCD9List.html">CD9List</a>*(* CD9List::filterBySet)(void *self, struct <a class="el" href="structCD9List.html">CD9List</a> *set)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>You will, usually, use this function when you want to eliminate more than one value from a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The current list. </td></tr>
    <tr><td class="paramname">set</td><td>The values that will be eliminated from list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structCD9List.html">CD9List</a> * The filtered list. </dd></dl>

</div>
</div>
<a class="anchor" id="a1c5d7f9a4582624c32b0d73269adcd8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structCD9List.html">CD9List</a>*(* CD9List::filterByValue)(void *self, const void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>You will use this function in order to filter a list by a given value, but this time you don't have to provide a comparator, since the built-in comparator will be used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The current list. </td></tr>
    <tr><td class="paramname">data</td><td>The value that will be eliminated from this list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structCD9List.html">CD9List</a> * The filtered list. </dd></dl>

</div>
</div>
<a class="anchor" id="aa89b586c2023685f16194effe3e79bd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* CD9List::find)(void *self, const void *data, CD9FindCallback cmp)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use this function to get the index of the first occurence of <code>data</code> in the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The current list. </td></tr>
    <tr><td class="paramname">data</td><td>The data you are looking for. </td></tr>
    <tr><td class="paramname">cmp</td><td>The comparator function used to determine if the data you are looking for is equal with a data in the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t The index of the element you are looking for. If there is no match for your query it will return <code>-1</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a44d0f916a39b661836528fa9238abb99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* CD9List::findByAddress)(void *self, const void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is a wrapper over <code>cd9list_find</code>. It is intended to ease the finding of elements in a list which stores addresses not copies of the data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The current list. </td></tr>
    <tr><td class="paramname">data</td><td>The data you want to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int See the return type of <code>cd9list_find</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a8833db5072ccff1a70608394b0b05d00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* CD9List::findByValue)(void *self, const void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for <code>cd9list_find</code>. It is intended to make your life easier if you need to find values in a list that stores copies, and by "copies" I mean pointers to copies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The current list. </td></tr>
    <tr><td class="paramname">data</td><td>The data you want to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int See the return value for <code>cd9list_find</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7e33d6d363a8eb355d9e0cc1150a53b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* CD9List::get)(void *self, size_t index)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this function to get the data of the node stored at that index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The current list. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the node where the data you want to retrieve resides.</td></tr>
    <tr><td class="paramname">void</td><td>* The data stored at that node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac391375276a5d2abccaac0bdf6cea24a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* CD9List::insert)(void *self, size_t index, const void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use this function to insert an item at the given list. If you pass an invalid index the function won't insert the value at all. This is a wrapper for <code>cd9list_insertCopy</code>, but it doesn't make a copy of the data you want to store, it just stores the address you give to him. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The current list. </td></tr>
    <tr><td class="paramname">index</td><td>The index where you want to insert the item. </td></tr>
    <tr><td class="paramname">data</td><td>The data you want to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void It doesn't return anything. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ff55079f64675c21d70c56034f4ed96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* CD9List::pop)(void *self)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use this function to delete the last element in the list and to delete it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The current list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void * The data of the last element in the list. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0d6db446dae3ee54db0d32e5eae9d47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* CD9List::popleft)(void *self)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use thid function to get the first element from the list and to delete it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The current list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void * The value of the first element from the list. </dd></dl>

</div>
</div>
<a class="anchor" id="a83bf6e968ecd901f6268b3e2eee7c990"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* CD9List::prepend)(void *self, const void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this function whenever you want to add a new node at the beggining of the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A pointer to the current list. </td></tr>
    <tr><td class="paramname">data</td><td>The data saved in the current node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void It doesn't return anything. </dd></dl>

</div>
</div>
<a class="anchor" id="af9889d78ce07976ad9969470d7b6446e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* CD9List::prependCopy)(void *self, const void *data, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is similar to <a class="el" href="structCD9List.html#aa7cac339279f3a9fd16972f5e5f572b7">appendCopy</a>, the only difference is that it appends the copy at the beginning of the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The current list. </td></tr>
    <tr><td class="paramname">data</td><td>The data you want to prepend. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data you want to prepend.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void It doesn't return anything. </dd></dl>

</div>
</div>
<a class="anchor" id="a4511b437cc1e26de0d1143377101310b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* CD9List::remove)(void *self, size_t index)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use this function to remove the element at the index specified as argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The current list. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the element thet you want to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int It returns <code>0</code> if the index you've passed is invalid or <code>1</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab12c45ac52b3b1eba1d8bafb48401427"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* CD9List::reverse)(void *self)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use this function to reverse the current list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The current list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void It doesn't return anything. </dd></dl>

</div>
</div>
<a class="anchor" id="a35c60ff759f31e18fd617183b85b5d69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structCD9List.html">CD9List</a>*(* CD9List::slice)(void *self, int start, int stop, size_t step)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use this function to receive a slice of the current list. The "slice" is a pointer to a a newly allocated block of memory which contains a portion of the current list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The current list. </td></tr>
    <tr><td class="paramname">start</td><td>The index where the slicing should start. If it is negative it is the equivalent of the length of the list + start. For example, in the list: [1, 2, 3, 4], -2 is the index of 3, because the length of the list is 4 and 4 + (-2) = 2, which is the index of the element 3. </td></tr>
    <tr><td class="paramname">stop</td><td>The index of the element where the slicing should stop. The same rules of negative indexes apply as above. Note that if you want to have the last element in your slice <code>stop</code> should be equal to <code>0</code>. A <code>0</code> stop means to slice until the end(inclusiv). </td></tr>
    <tr><td class="paramname">step</td><td>The range between elements in the slice.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structCD9List.html">CD9List</a> * A pointer to the slice. </dd></dl>

</div>
</div>
<a class="anchor" id="aaacc616c1a41f08feaef507b40dae30a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* CD9List::sort)(void *self, int(*cmp)(const void *a, const void *b))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use this function to sort a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The current list. </td></tr>
    <tr><td class="paramname">cmp</td><td>The comparator function <code>cmp</code> should returna value less than <code>0</code> if <code>a</code> is less than <code>b</code>, <code>0</code> if they are equal. Or a value bigger than <code>1</code> if <code>a</code> is bigger than <code>b</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void It doesn't return anything. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/home/cristi/projects/cd9list/src/<a class="el" href="cd9list_8h_source.html">cd9list.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Apr 5 2015 03:13:24 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
